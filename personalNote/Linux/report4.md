# Linux实验报告四

## 1. 实验要求

1. 进程可以通过`top`查看实时的状态，还可以通过`ps`来静态查看当前的信息，同时我们还可以使用`pstree`来查看当前活跃进程的树形结构。使用以上几个命令输出信息并解释每个字段的含义。

2. 使用`crontab`创建一个周期性任务，任务可以是执行一条任意命令。解释每个字段的含义。

## 2. 实验步骤

### 2.1 运行`top`命令

- 命令使用

  top命令是一个前台程序，可以交互，可以查看一些进程的状态及系统信息：

  | q    | 退出程序                                                     |
  | ---- | ------------------------------------------------------------ |
  | I    | 切换显示平均负载和启动时间的信息                             |
  | P    | 更具cpu使用百分比大小进行排序                                |
  | M    | 根据驻留内存大小进行排序                                     |
  | i    | 忽略闲置和僵死的进程，这是一个开关式的命令                   |
  | k    | 终止一个进程，系统提示输入PID及发送的信号值，一般终止的信号值是15，强制终止的信号值是9 |

- 输出结果

  ![image-20221121214310785](https://dreaife-1306766477.cos.ap-nanjing.myqcloud.com/image-20221121214310785.png)

- 结果分析

  > 1. 第一行
  >
  >    top：当前程序名称
  >
  >    21:42:22：当前系统时间
  >
  >    up 2 min：机器启动时间
  >
  >    1 user：当前只有一名用户
  >
  >    load average: 0.57，0.44，0.19：对应1,5,15分钟内cpu的平均负载
  >
  >    > load中的四种显示：
  >    >
  >    > 1. load=0 cpu没有任务
  >    > 2. load<1 cpu任务不多，资源充足
  >    > 3. load=1 cpu任务已满，所有资源被使用，但还在能力范围之内
  >    > 4. load>1 cpu任务已满，所有资源被使用，还有大量进程在请求
  >
  > 2. 第二行
  >
  >    任务：362 total：进程总数
  >
  >    1 running：1个正在运行的进程
  >
  >    361 sleeping：361个睡眠的进程数
  >
  >    0 stopped：没有停止的进程
  >
  >    0 zombie：没有僵尸进程
  >
  > 3. 第三行
  >
  >    %Cpu(s): 0.3us：用户空间进程占用cpu百分比
  >
  >    0.5 sy：内核空间运行占用cpu百分比
  >
  >    0.0 ni：用户进程空间内改变过优先级的进程占用cpu百分比
  >
  >    99.2 id：空闲cpu百分比
  >
  >    0.0 wa：等待输入输出的cpu时间的百分比
  >
  >    0.0 hi：硬中断占用cpu的百分比
  >
  >    0.1 si：软中断占用cpu时间的百分比
  >
  >    0.0 st：虚拟cpu等待实际cpu的时间的百分比
  >
  > 4. 第四行
  >
  >    3889.8 total：物理内存总量
  >
  >    624.3 free：空闲内存总量
  >
  >    1479.0 used：使用的物理内存总量
  >
  >    1786.6 buff/cache：用作内核缓存的内存量
  >
  > 5. 第五行
  >
  >    3898.0 total：交换区总量
  >
  >    3898.0 free：空闲的交换区总量
  >
  >    0.0 used：使用的交换区总量
  >
  >    2110.8 cache Mem：缓冲的交换区总量
  >
  > 6. 第六行
  >
  >    进程号：进程id
  >
  >    USER：该进程的所属用户
  >
  >    PR：该进程执行的优先级priority值
  >
  >    NI：该进程的nice值
  >
  >    VIRT：该进程任务所使用的虚拟内存的总数
  >
  >    RES：该进程所使用的物理内存总数，也称为驻留内存总数
  >
  >    SHR：该进程共享内存的大小
  >
  >    S：该进程的状态 S=sleep R=running Z=zombie
  >
  >    %CPU：该进程cpu的利用率
  >
  >    %MEM：该进程内存的利用率
  >
  >    TIME+：该进程活跃的总时间
  >
  >    COMMAND：该进程运行的名字

### 2.2 运行`ps`命令

- 命令使用

  ps是常用的查看进程的工具之一。

  ```bash
  ps -l # 显示自己这次登录的bash相关进程信息罗列出来
  ps -afxo # 自定义所需要的参数显示
  ## 如 ps -afxo user,ppid,pid,pgid,command
  ps aux # 罗列出所有进程信息，可搭配grep命令和正则表达式使用ps aux | grep zsh
  ps axjf # 查看时将连同部分的进程呈树状显示出来
  ```

- 输出结果

  ![image-20221121222255216](https://dreaife-1306766477.cos.ap-nanjing.myqcloud.com/image-20221121222255216.png)

- 结果分析

  内容含义：

  | PID  | 进程的ID          |
  | ---- | ----------------- |
  | TTY  | 终端ID            |
  | TIME | 进程消耗cpu的时间 |
  | CMD  | 命令的名称和参数  |

  总共运行了两个命令`bash`和`ps`，id分别为2746和30097，终端id均为pts/0，消耗了cpu时间为0s。

### 2.3 运行`pstree`命令

- 命令使用

  通过pstree可以直观的看到相同的进程数量，可以看到进程间的相关性。

  ```bash
  pstree
  pstree -up
  # -p 同时列出每个process的PID
  # -u 同时列出每个process的所属账号
  # -A 各程序树之间以ASCII字元来链接
  ```

- 输出结果

  ![image-20221121223310569](https://dreaife-1306766477.cos.ap-nanjing.myqcloud.com/image-20221121223310569.png)

- 结果分析

  可以看到所有的进程都是依附在systemd这个进程下面，它的进程PID是1，因为它是由Linux内核主动调用的一个进程。

  可以看到935这个进程有两个子进程，分别为972、976。

