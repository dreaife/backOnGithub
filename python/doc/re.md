# 正则表达式

## 介绍

正则表达式(Regular Expression)是一种文本模式，包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为"元字符"），可以用来描述和匹配字符串的特定模式。

正则表达式是一种用于模式匹配和搜索文本的工具。

正则表达式提供了一种灵活且强大的方式来查找、替换、验证和提取文本数据。

正则表达式可以应用于各种编程语言和文本处理工具中，如 JavaScript、Python、Java、Perl 等。

```js
// 从字符串 str 中提取数字部分的内容(匹配一次)：
var str = "abc123def";
var patt1 = /[0-9]+/;
document.write(str.match(patt1));
```

## 在线工具

[在线工具](https://c.runoob.com/front-end/854/)

## 正则表达式的模式

正则表达式的模式可以包括以下内容：

- 字面值字符：例如字母、数字、空格等，可以直接匹配它们自身。
- 特殊字符：例如点号 .、星号 *、加号 +、问号 ? 等，它们具有特殊的含义和功能。
- 字符类：用方括号 [ ] 包围的字符集合，用于匹配方括号内的任意一个字符。
- 元字符：例如 \d、\w、\s 等，用于匹配特定类型的字符，如数字、字母、空白字符等。
- 量词：例如 {n}、{n,}、{n,m} 等，用于指定匹配的次数或范围。
- 边界符号：例如 ^、$、\b、\B 等，用于匹配字符串的开头、结尾或单词边界位置。

# 简介

正则表达式的使用，可以通过简单的办法来实现强大的功能。下面先给出一个简单的示例：

![image](https://dreaife-1306766477.cos.ap-nanjing.myqcloud.com/image.png)

- `^` 为匹配输入字符串的开始位置。
- `[0-9]+`匹配多个数字， `[0-9]` 匹配单个数字，`+` 匹配一个或者多个。
- `abc$`匹配字母 `abc` 并以 `abc` 结尾，`$` 为匹配输入字符串的结束位置。

我们在写用户注册表单时，只允许用户名包含字符、数字、下划线和连接字符 -，并设置用户名的长度，我们就可以使用以下正则表达式来设定。

```re
^[a-zA-Z0-9_-]{3,15}$
```

- ^ 表示匹配字符串的开头。
- [a-zA-Z0-9_-] 表示字符集，包含小写字母、大写字母、数字、下划线和连接字符 -。
- {3,15} 表示前面的字符集最少出现 3 次，最多出现 15 次，从而限制了用户名的长度在 3 到 15 个字符之间。
- $ 表示匹配字符串的结尾。

## 正则表达式元字符和特性

1. 字符匹配

    - 普通字符：普通字符按照字面意义进行匹配，例如匹配字母 "a" 将匹配到文本中的 "a" 字符。
    - 元字符：元字符具有特殊的含义，例如 \d 匹配任意数字字符，\w 匹配任意字母数字字符，. 匹配任意字符（除了换行符）等。
2. 量词

    - *：匹配前面的模式零次或多次。
    - +：匹配前面的模式一次或多次。
    - ?：匹配前面的模式零次或一次。
    - {n}：匹配前面的模式恰好 n 次。
    - {n,}：匹配前面的模式至少 n 次。
    - {n,m}：匹配前面的模式至少 n 次且不超过 m 次。
3. 字符类

    - [ ]：匹配括号内的任意一个字符。例如，[abc] 匹配字符 "a"、"b" 或 "c"。
    - [^ ]：匹配除了括号内的字符以外的任意一个字符。例如，[^abc] 匹配除了字符 "a"、"b" 或 "c" 以外的任意字符。
4. 边界匹配

    - ^：匹配字符串的开头。
    - $：匹配字符串的结尾。
    - \b：匹配单词边界。
    - \B：匹配非单词边界。
5. 分组和捕获

    - ( )：用于分组和捕获子表达式。
    - (?: )：用于分组但不捕获子表达式。
6. 特殊字符

    - \：转义字符，用于匹配特殊字符本身。
    - .：匹配任意字符（除了换行符）。
    - |：用于指定多个模式的选择。

## 为什么使用正则表达式？

典型的搜索和替换操作要求您提供与预期的搜索结果匹配的确切文本。虽然这种技术对于对静态文本执行简单搜索和替换任务可能已经足够了，但它缺乏灵活性，若采用这种方法搜索动态文本，即使不是不可能，至少也会变得很困难。

通过使用正则表达式，可以：

- 测试字符串内的模式。
  例如，可以测试输入字符串，以查看字符串内是否出现电话号码模式或信用卡号码模式。这称为数据验证。
- 替换文本。
  可以使用正则表达式来识别文档中的特定文本，完全删除该文本或者用其他文本替换它。
- 基于模式匹配从字符串中提取子字符串。
  可以查找文档内或输入域内特定的文本。

例如，您可能需要搜索整个网站，删除过时的材料，以及替换某些 HTML 格式标记。在这种情况下，可以使用正则表达式来确定在每个文件中是否出现该材料或该 HTML 格式标记。此过程将受影响的文件列表缩小到包含需要删除或更改的材料的那些文件。然后可以使用正则表达式来删除过时的材料。最后，可以使用正则表达式来搜索和替换标记。

## 应用领域

目前，正则表达式已经在很多软件中得到广泛的应用，包括 *nix（Linux, Unix等）、HP 等操作系统，PHP、C#、Java 等开发环境，以及很多的应用软件中，都可以看到正则表达式的影子。

命令或环境 | . | [ ] | ^ | $ | \\( \\) | \\{ \\} | ? | + | \| | ( )
---|---|---|---|---|---|---|---|---|---|---
vi          | √ | √ | √ | √ | √ |   |   |   | 　
Visual C++  | √ | √ | √ | √ | √ |   |   |
awk         | √ | √ | √ | √ |   |awk是支持该语法的，只是要在命令行加入 --posix or --re-interval参数即可，可见man awk中的interval expression|√|√|√|√
sed         | √ | √ | √ | √ | √ | √ |   |   |   |
delphi      | √ | √ | √ | √ | √ |   | √ | √ | √ | √
python      | √ | √ | √ | √ | √ | √ | √ | √ | √ | √
java        | √ | √ | √ | √ | √ | √ | √ | √ | √ | √
javascript  | √ | √ | √ | √ | √ |   | √ | √ | √ | √
php         | √ | √ | √ | √ | √ |   |   |   |   |
perl        | √ | √ | √ | √ | √ |   | √ | √ | √ | √
C#          | √ | √ | √ | √ |   |   | √ | √ | √ | √

# 正则表达式 - 语法

正则表达式是一种用于匹配和操作文本的强大工具，它是由一系列字符和特殊字符组成的模式，用于描述要匹配的文本模式。

正则表达式可以在文本中查找、替换、提取和验证特定的模式。

构造正则表达式的方法和创建数学表达式的方法一样。也就是用多种元字符与运算符可以将小的表达式结合在一起来创建更大的表达式。正则表达式的组件可以是单个的字符、字符集合、字符范围、字符间的选择或者所有这些组件的任意组合。

正则表达式是由普通字符（例如字符 a 到 z）以及特殊字符（称为"元字符"）组成的文字模式。模式描述在搜索文本时要匹配的一个或多个字符串。正则表达式作为一个模板，将某个字符模式与所搜索的字符串进行匹配。

## 普通字符

普通字符包括没有显式指定为元字符的所有可打印和不可打印字符。这包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号。

- `[ABC]`
    匹配 [...] 中的所有字符，例如 [aeiou] 匹配字符串 "google runoob taobao" 中所有的 e o u a 字母。
- `[^ABC]`  
    匹配除了 [...] 中字符的所有字符，例如 [^aeiou] 匹配字符串 "google runoob taobao" 中除了 e o u a 字母的所有字符。
- `[A-Z]`  
    [A-Z] 表示一个区间，匹配所有大写字母，[a-z] 表示所有小写字母
- `.`  
    匹配除换行符（\n、\r）之外的任何单个字符，相等于 [^\n\r]。
- `[\s\S]`  
    匹配所有。\s 是匹配所有空白符，包括换行，\S 非空白符，不包括换行。
- `\w`  
    匹配字母、数字、下划线。等价于 [A-Za-z0-9_]
- `\d`
    匹配任意一个阿拉伯数字（0 到 9）。等价于 [0-9]

## 非打印字符

非打印字符也可以是正则表达式的组成部分。下表列出了表示非打印字符的转义序列：
字符 | 描述
--- |---
\cx | 匹配由x指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的'c'字符。
\f  | 匹配一个换页符。等价于 \x0c 和 \cL。
\n  | 匹配一个换行符。等价于 \x0a 和 \cJ。
\r  | 匹配一个回车符。等价于 \x0d 和 \cM。
\s  | 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。注意 Unicode 正则表达式会匹配全角空格符。
\S  | 匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。
\t  | 匹配一个制表符。等价于 \x09 和 \cI。
\v  | 匹配一个垂直制表符。等价于 \x0b 和 \cK。

## 特殊字符

所谓特殊字符，就是一些有特殊含义的字符，如上面说的 `runoo*b` 中的 `*`，简单的说就是表示任何字符串的意思。如果要查找字符串中的`*`符号，则需要对`*`进行转义，即在其前加一个`\`，`runo\*ob`匹配字符串`runo*ob`。

许多元字符要求在试图匹配它们时特别对待。若要匹配这些特殊字符，必须首先使字符"转义"，即，将反斜杠字符\ 放在它们前面。下表列出了正则表达式中的特殊字符：
特别字符 | 描述
---|---
\$ | 匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 \$ 也匹配 '\n' 或 '\r'。要匹配 \$ 字符本身，请使用\\$
( ) | 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 \\( 和 \\)
\- | 匹配前面的子表达式零次或多次。要匹配 \* 字符，请使用\\*
\+ | 匹配前面的子表达式一次或多次。要匹配 \+ 字符，请使用\\+
\. | 匹配除换行符 \n 之外的任何单字符。要匹配 \. ，请使用\\.
\[ | 标记一个中括号表达式的开始。要匹配 \[，请使用 \\[。
\? | 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 \? 字符，请使用 \\?。
\\ | 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， 'n' 匹配字符 'n'。'\n' 匹配换行符。序列 '\\\\' 匹配"\\"，而'\\('则匹配"\("。
\^ | 匹配输入字符串的开始位置，除非在方括号表达式中使用，当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合。要匹配 \^ 字符本身，请使用\\^。
\{ | 标记限定符表达式的开始。要匹配 {，请使用 \{。
\\| | 指明两项之间的一个选择。要匹配 \|，请使用 \\\|。

## 限定符

限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有 * 或 + 或 ? 或 {n} 或 {n,} 或 {n,m} 共6种。

正则表达式的限定符有：

- \*
  匹配前面的子表达式零次或多次。例如，zo*能匹配 "z" 以及 "zoo"。* 等价于 {0,}。
- \+
  匹配前面的子表达式一次或多次。例如，zo+ 能匹配 "zo" 以及 "zoo"，但不能匹配 "z"。+ 等价于 {1,}。
- ?
  匹配前面的子表达式零次或一次。例如，do(es)? 可以匹配 "do" 、 "does"、 "doxy" 中的 "do" 和 "does"。? 等价于 {0,1}。
- {n}
  n 是一个非负整数。匹配确定的 n 次。例如，o{2} 不能匹配 "Bob" 中的 o，但是能匹配 "food" 中的两个 o。
- {n,}
  n 是一个非负整数。至少匹配n 次。例如，`o{2,}`不能匹配"Bob"中的 o，但能匹配 "foooood"中的所有o。`o{1,}` 等价于 o+。`o{0,}`则等价于`o*`。
- {n,m}
  m 和 n 均为非负整数，其中 n <= m。最少匹配 n 次且最多匹配 m 次。例如，`o{1,3}` 将匹配 "fooooood" 中的前三个 o。`o{0,1}`等价于`o?`。请注意在逗号和两个数之间不能有空格。

\* 和 + 限定符都是贪婪的，因为它们会尽可能多的匹配文字，只有在它们的后面加上一个 ? 就可以实现非贪婪或最小匹配。

## 定位符

定位符使您能够将正则表达式固定到行首或行尾。它们还使您能够创建这样的正则表达式，这些正则表达式出现在一个单词内、在一个单词的开头或者一个单词的结尾。

定位符用来描述字符串或单词的边界，\^ 和 \$ 分别指字符串的开始与结束，\b 描述单词的前或后边界，\B 表示非单词边界。

正则表达式的定位符有：

- \^
  匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \n 或 \r 之后的位置匹配。
- \$
  匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，\$ 还会与 \n 或 \r 之前的位置匹配。
- \b
  匹配一个单词边界，即字与空格间的位置。
- \B
  非单词边界匹配。

## 选择

用圆括号 () 将所有选择项括起来，相邻的选择项之间用 | 分隔。

() 表示捕获分组，() 会把每个分组里的匹配的值保存起来， 多个匹配值可以通过数字 n 来查看(n 是一个数字，表示第 n 个捕获组的内容)。

但用圆括号会有一个副作用，使相关的匹配会被缓存，此时可用 ?: 放在第一个选项前来消除这种副作用。

其中 ?: 是非捕获元之一，还有两个非捕获元是 ?= 和 ?!，这两个还有更多的含义，前者为正向预查，在任何开始匹配圆括号内的正则表达式模式的位置来匹配搜索字符串，后者为负向预查，在任何开始不匹配该正则表达式模式的位置来匹配搜索字符串。

以下列出 ?=、?<=、?!、?<! 的使用区别

- exp1(?=exp2)：查找 exp2 前面的 exp1。
- (?<=exp2)exp1：查找 exp2 后面的 exp1。
- exp1(?!exp2)：查找后面不是 exp2 的 exp1。
- (?<!exp2)exp1：查找前面不是 exp2 的 exp1。

## 反向引用

对一个正则表达式模式或部分模式两边添加圆括号将导致相关匹配存储到一个临时缓冲区中，所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。缓冲区编号从1开始，最多可存储99个捕获的子表达式。每个缓冲区都可以使用\n访问，其中n为一个标识特定缓冲区的一位或两位十进制数。

可以使用非捕获元字符 ?:、?= 或 ?! 来重写捕获，忽略对相关匹配的保存。

反向引用的最简单的、最有用的应用之一，是提供查找文本中两个相同的相邻单词的匹配项的能力。

`Is is the cost of of gasoline going up up?`

上面的句子很显然有多个重复的单词。如果能设计一种方法定位该句子，而不必查找每个单词的重复出现，那该有多好。下面的正则表达式使用单个子表达式来实现这一点：

```js
// 查找重复的单词：
var str = "Is is the cost of of gasoline going up up";
var patt1 = /\b([a-z]+) \1\b/igm;
document.write(str.match(patt1));
```

捕获的表达式，正如 [a-z]+ 指定的，包括一个或多个字母。正则表达式的第二部分是对以前捕获的子匹配项的引用，即，单词的第二个匹配项正好由括号表达式匹配。\1指定第一个子匹配项。

单词边界元字符确保只检测整个单词。否则，诸如 "is issued" 或 "this is" 之类的词组将不能正确地被此表达式识别。

正则表达式后面的全局标记 g 指定将该表达式应用到输入字符串中能够查找到的尽可能多的匹配。

表达式的结尾处的不区分大小写 i 标记指定不区分大小写。

多行标记 m 指定换行符的两边可能出现潜在的匹配。

反向引用还可以将通用资源指示符 (URI) 分解为其组件。假定您想将下面的 URI 分解为协议（ftp、http 等等）、域地址和页/路径：

`https://www.runoob.com:80/html/html-tutorial.html`

下面的正则表达式提供该功能：

```js
// 输出所有匹配的数据：
var str = "https://www.runoob.com:80/html/html-tutorial.html";
var patt1 = /(\w+):\/\/([^/:]+)(:\d*)?([^# ]*)/;
arr = str.match(patt1);
for (var i = 0; i < arr.length ; i++) {
    document.write(arr[i]);
    document.write("<br>");
}
```

第三行代码 str.match(patt1) 返回一个数组，实例中的数组包含 5 个元素，索引 0 对应的是整个字符串，索引 1 对应第一个匹配符（括号内），以此类推。

第一个括号子表达式捕获 Web 地址的协议部分。该子表达式匹配在冒号和两个正斜杠前面的任何单词。

第二个括号子表达式捕获地址的域地址部分。子表达式匹配非 : 和 / 之后的一个或多个字符。

第三个括号子表达式捕获端口号（如果指定了的话）。该子表达式匹配冒号后面的零个或多个数字。只能重复一次该子表达式。

最后，第四个括号子表达式捕获 Web 地址指定的路径和 / 或页信息。该子表达式能匹配不包括 # 或空格字符的任何字符序列。

将正则表达式应用到上面的 URI，各子匹配项包含下面的内容：

- 第一个括号子表达式包含 `https`
- 第二个括号子表达式包含 `www.runoob.com`
- 第三个括号子表达式包含 `:80`
- 第四个括号子表达式包含 `/html/html-tutorial.html`

# 正则表达式 - 修饰符（标记）

标记也称为修饰符，正则表达式的标记用于指定额外的匹配策略。

标记不写在正则表达式里，标记位于表达式之外，格式如下：

```js
/pattern/flags
```

下表列出了正则表达式常用的修饰符：
修饰符 |含义 |描述
---|---|---
i| ignore-不区分大小写| 将匹配设置为不区分大小写，搜索时不区分大小写: A 和 a 没有区别。
g| global-全局匹配|  查找所有的匹配项。
m| multi line-多行匹配| 使边界字符 \^ 和 \$ 匹配每一行的开头和结尾，记住是多行，而不是整个字符串的开头和结尾。
s| 特殊字符圆点.中包含换行符\n| 默认情况下的圆点 `.` 是匹配除换行符 \n 之外的任何字符，加上 s 修饰符之后, `.` 中包含换行符 \n。

# 正则表达式 - 运算符优先级

正则表达式从左到右进行计算，并遵循优先级顺序，这与算术表达式非常类似。

相同优先级的从左到右进行运算，不同优先级的运算先高后低。下表从最高到最低说明了各种正则表达式运算符的优先级顺序：
运算符 | 描述
---|---
`\` | 转义符
`()`, `(?:)`, `(?=)`, `[]` | 圆括号和方括号
`*`, `+`, `?`, `{n}`, `{n,}`, `{n,m}` | 限定符
`^`, `$`, `\`任何元字符、任何字符 | 定位点和序列（即：位置和顺序）
`|` | 替换，"或"操作 字符具有高于替换运算符的优先级，使得"m|food"匹配"m"或"food"。若要匹配"mood"或"food"，请使用括号创建子表达式，从而产生"(m|f)ood"。

以下是一些常见正则表达式运算符按照优先级从高到低的顺序：

- 转义符号： \ 是用于转义其他特殊字符的转义符号。它具有最高的优先级。
- 括号： 圆括号 () 用于创建子表达式，具有高于其他运算符的优先级。
- 量词： 量词指定前面的元素可以重复的次数。
- 字符类： 字符类使用方括号 [] 表示，用于匹配括号内的任意字符。
- 断言： 断言是用于检查字符串中特定位置的条件的元素。
- 连接： 连接在没有其他运算符的情况下表示字符之间的简单连接。
- 管道： 管道符号 | 表示"或"关系，用于在多个模式之间选择一个。

# 正则表达式 - 匹配规则

## 基本模式匹配

模式，是正则表达式最基本的元素，它们是一组描述字符串特征的字符。模式可以很简单，由普通的字符串组成，也可以非常复杂，往往用特殊的字符表示一个范围内的字符、重复出现，或表示上下文。

## 字符簇

在 INTERNET 的程序中，正则表达式通常用来验证用户的输入。当用户提交一个 FORM 以后，要判断输入的电话号码、地址、EMAIL 地址、信用卡号码等是否有效，用普通的基于字面的字符是不够的。

所以要用一种更自由的描述我们要的模式的办法，它就是字符簇。

## 确定重复出现

到现在为止，你已经知道如何去匹配一个字母或数字，但更多的情况下，可能要匹配一个单词或一组数字。一个单词有若干个字母组成，一组数字有若干个单数组成。跟在字符或字符簇后面的花括号({})用来确定前面的内容的重复出现的次数。
